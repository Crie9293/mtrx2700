.syntax unified
.thumb
.global assembly_function

// Clock Registers
.equ RCC, 0x40021000   // Reset clock control. Base clock register
.equ AHBENR, 0x14      // Enable GPIO clocks
.equ APB2ENR, 0x18     // Enable USART1

// Addresses and offsets for USART1
.equ USART1, 0x40013800 // Base address for USART1
.equ USART_CR1, 0x00   // Control register 1
.equ USART_BRR, 0x0C   // Baud rate register
.equ USART_ISR, 0x1C   // Status Register
.equ USART_TDR, 0x28   // Transmit data register

// GPIO
.equ GPIOA, 0x48000000  // GPIO Port A base address (for user button)
.equ GPIOC, 0x48000800  // GPIO Port C base address (for USART)
.equ GPIO_MODER, 0x00   // Mode selection
.equ GPIO_OSPEEDR, 0x08 // Speed selection
.equ GPIO_AFRL, 0x20    // Alternate function specification
.equ GPIO_IDR, 0x10     // Input Data Register
.equ GPIOA_ENABLE, 17   // Bit to enable clock for Port A
.equ GPIOC_ENABLE, 19   // Bit to enable clock for Port C

// UART
.equ USART1_ENABLE, 14  // Bit to enable USART1 clock
.equ UART_TXE, 7        // Transmit data register empty bit
.equ UART_TE, 3         // Bit to enable transmission
.equ UART_RE, 2         // Bit to enable receive
.equ UART_UE, 0         // Bit to enable USART1 submodule

// Button
.equ USER_BUTTON, 0     // User button is connected to PA0

// Terminating character
.equ TERM_CHAR, '$'     // User-defined terminating character

.data
.align
txString:
    .asciz "Khit\r\n"    // The r is a carriage return. The n is a new line
txLength:
    .byte 6

.text
// Entry point
assembly_function:
    BL enableGPIOClocks
    BL enableUSART
    B buttonMonitor      // Instead of directly transmitting, monitor button

enableGPIOClocks:
    LDR R0, =RCC              // Load register with clock base address
    LDR R1, [R0, #AHBENR]     // Load R1 with peripheral clock register's values
    ORR R1, 1 << GPIOC_ENABLE // Set relevant bits to enable clock for Port C
    ORR R1, 1 << GPIOA_ENABLE // Also enable clock for Port A (for user button)
    STR R1, [R0, #AHBENR]     // Store value back in register to enable clocks
    BX LR

enableUSART:
    // Step 1: Choose pin mode
    LDR R0, =GPIOC
    LDR R1, =0xA00
    STR R1, [R0, #GPIO_MODER]
    
    // Step 2: Set specific alternate function
    MOV R1, 0x77
    STRB R1, [R0, #GPIO_AFRL + 2]
    
    // Step 3: High clock speed and enable USART1 clock
    LDR R1, =0xF00
    STR R1, [R0, #GPIO_OSPEEDR]
    LDR R0, =RCC
    LDR R1, [R0, #APB2ENR]
    ORR R1, 1 << USART1_ENABLE
    STR R1, [R0, #APB2ENR]
    
    // Step 4: Baud rate and enable USART1 (both transmit and receive)
    MOV R1, #0x46
    LDR R0, =USART1
    STRH R1, [R0, #USART_BRR]
    LDR R0, =USART1
    LDR R1, [R0, #USART_CR1]
    ORR R1, 1 << UART_TE | 1 << UART_RE | 1 << UART_UE
    STR R1, [R0, #USART_CR1]
    BX LR

// New function: Monitor button press
buttonMonitor:
    LDR R0, =GPIOA            // Load GPIO Port A address (for button)
    LDR R1, [R0, #GPIO_IDR]   // Read input data register
    TST R1, 1 << USER_BUTTON  // Test if button bit is set (button is pressed)
    BEQ buttonMonitor         // If not pressed, keep checking
    
    // Button is pressed, load string address into R1 and call transmitString
    LDR R1, =txString
    BL transmitString
    
    // Small delay to debounce button
    LDR R9, =0x50000
debounce:
    SUBS R9, #1
    BGT debounce
    
    B buttonMonitor           // Go back to monitoring button

// New function: Transmit any string passed in R1
transmitString:
    PUSH {R4-R7, LR}          // Save registers we'll use
    MOV R6, R1                // Copy string address to R6
    MOV R7, #0                // Initialize character counter
    
    // First pass to count characters until null terminator
countLoop:
    LDRB R4, [R6, R7]         // Load character at position R7
    CMP R4, #0                // Check if it's null terminator
    BEQ prepTransmit          // If yes, prepare for transmission
    ADD R7, #1                // Increment counter
    B countLoop               // Continue counting
    
prepTransmit:
    LDR R0, =USART1           // Load USART1 base address
    MOV R4, R7                // Copy character count to R4
    MOV R3, R1                // Copy string address to R3

transmitLoop:
    LDR R5, [R0, #USART_ISR]  // Load the status register into R5
    ANDS R5, 1 << UART_TXE    // Check if the transmission data register is empty
    BEQ transmitLoop          // Wait (loop) until it is empty
    
    CMP R4, #0                // Check if we've sent all characters
    BEQ sendTerminator        // If yes, send terminating character
    
    LDRB R5, [R3], #1         // Load the next character in the string and point to the next entry
    STRB R5, [R0, #USART_TDR] // Transmit the character
    SUBS R4, #1               // Decrement character count
    B transmitLoop            // Continue transmitting

sendTerminator:
    LDR R5, [R0, #USART_ISR]  // Check status register again
    ANDS R5, 1 << UART_TXE    // Check if ready to transmit
    BEQ sendTerminator        // Wait until ready
    
    MOV R5, #TERM_CHAR        // Load terminating character
    STRB R5, [R0, #USART_TDR] // Transmit terminating character
    
    POP {R4-R7, PC}           // Restore registers and return

// Original delay function (used for debugging if needed)
delayLoop:
    LDR R9, =0xfffff
delayInner:
    SUBS R9, #1
    BGT delayInner
    BX LR
